"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FireblocksSDK = void 0;
const api_client_1 = require("./api-client");
const api_token_provider_1 = require("./api-token-provider");
const query_string_1 = __importDefault(require("query-string"));
const qs_1 = require("qs");
const types_1 = require("./types");
const pii_client_1 = require("./pii-client");
const ncw_api_client_1 = require("./ncw-api-client");
const staking_api_client_1 = require("./staking/staking-api-client");
const public_key_info_1 = require("./common/public_key_info");
__exportStar(require("./types"), exports);
const DEFAULT_MAX_PAGE_SIZE = 100;
class FireblocksSDK {
    /**
     * Creates a new Fireblocks API Client
     * @param privateKey A string representation of your private key
     * @param apiKey Your api key. This is a uuid you received from Fireblocks
     * @param apiBaseUrl The fireblocks server URL. Leave empty to use the default server
     * @param authProvider
     * @param sdkOptions
     */
    constructor(privateKey, apiKey, apiBaseUrl = "https://api.fireblocks.io", authProvider = undefined, sdkOptions) {
        this.authProvider = !!authProvider ? authProvider : new api_token_provider_1.ApiTokenProvider(privateKey, apiKey);
        if (!!apiBaseUrl) {
            this.apiBaseUrl = apiBaseUrl;
        }
        this.apiClient = new api_client_1.ApiClient(this.authProvider, this.apiBaseUrl, sdkOptions);
        if (sdkOptions === null || sdkOptions === void 0 ? void 0 : sdkOptions.travelRuleOptions) {
            this.piiClient = new pii_client_1.PIIEncryption(sdkOptions.travelRuleOptions);
        }
        this.apiNcw = new ncw_api_client_1.NcwApiClient(this.apiClient);
        this.stakingApiClient = new staking_api_client_1.StakingApiClient(this.apiClient);
    }
    /**
     * NCW API Namespace
     *
     * @readonly
     * @type {NcwSdk}
     */
    get NCW() {
        return this.apiNcw;
    }
    /**
     * Get the instance of ApiClient used by the FireblocksSDK
     */
    getApiClient() {
        return this.apiClient;
    }
    /**
     * Get all staking chains
     */
    getStakingChains() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.getChains();
        });
    }
    /**
     * Get chain info
     */
    getStakingChainInfo(chainDescriptor) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.getChainInfo(chainDescriptor);
        });
    }
    /**
     * Get staking positions summary
     */
    getStakingPositionsSummary() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.getPositionsSummary();
        });
    }
    /**
     * Get staking positions summary by vault
     */
    getStakingPositionsSummaryByVault() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.getPositionsSummaryByVault();
        });
    }
    /**
     * Initiate staking stake on a chain
     */
    executeStakingStake(chainDescriptor, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.stake(chainDescriptor, body);
        });
    }
    /**
     * Execute staking unstake on a chain
     */
    executeStakingUnstake(chainDescriptor, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.unstake(chainDescriptor, body);
        });
    }
    /**
     * Execute staking withdraw on a chain
     */
    executeStakingWithdraw(chainDescriptor, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.withdraw(chainDescriptor, body);
        });
    }
    /**
     * Execute staking claim rewards on a chain
     */
    executeStakingClaimRewards(chainDescriptor, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.withdraw(chainDescriptor, body);
        });
    }
    /**
     * Execute staking split on a chain
     */
    executeStakingSplit(chainDescriptor, body) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.split(chainDescriptor, body);
        });
    }
    /**
     * Get all staking positions, optionally filtered by chain
     */
    getStakingPositions(chainDescriptor) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.getPositions(chainDescriptor);
        });
    }
    /**
     * Get a staking position by id
     */
    getStakingPosition(positionId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.getPosition(positionId);
        });
    }
    /**
     * Get all staking providers
     */
    getStakingProviders() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.getProviders();
        });
    }
    /**
     * Approve staking provider terms of service
     */
    approveStakingProviderTermsOfService(providerId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.stakingApiClient.approveProviderTermsOfService(providerId);
        });
    }
    /**
     * Gets all assets that are currently supported by Fireblocks
     */
    getSupportedAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/supported_assets");
        });
    }
    /**
     * Sets asset price
     * @param id The asset ID
     * @param currency The currency (according to ISO 4217 currency codes)
     * @param price The price in currency
     */
    setAssetPrice(id, currency, price) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/assets/prices/${id}`, { currency, price });
        });
    }
    /**
     * Gets a list of vault accounts per page matching the given filter or path
     * @param pagedVaultAccountsRequestFilters Filters for the first request
     */
    getVaultAccountsWithPageInfo(pagedVaultAccountsRequestFilters) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/vault/accounts_paged?${query_string_1.default.stringify(pagedVaultAccountsRequestFilters)}`);
        });
    }
    /**
     * Gets a list of asset wallets per page matching the given filter or path
     * @param getVaultWalletsFilters Filters for the first request
     */
    getAssetWallets(getVaultWalletsFilters) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/vault/asset_wallets?${query_string_1.default.stringify(getVaultWalletsFilters)}`);
        });
    }
    /**
     * Gets a single vault account
     * @param vaultAccountId The vault account ID
     */
    getVaultAccountById(vaultAccountId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/vault/accounts/${vaultAccountId}`);
        });
    }
    /**
     * Gets a single vault account asset
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset to get
     */
    getVaultAccountAsset(vaultAccountId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/vault/accounts/${vaultAccountId}/${assetId}`);
        });
    }
    /**
     * Gets a single vault account asset balance after forcing refresh from the blockchain
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset to get
     * @param requestOptions
     */
    refreshVaultAssetBalance(vaultAccountId, assetId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/vault/accounts/${vaultAccountId}/${assetId}/balance`, "{}", requestOptions);
        });
    }
    /**
     * Gets deposit addresses for an asset in a vault account
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset for which to get the deposit address
     */
    getDepositAddresses(vaultAccountId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/vault/accounts/${vaultAccountId}/${assetId}/addresses`);
        });
    }
    /**
     * Gets utxo list for an asset in a vault account
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset for which to get the utxo list
     */
    getUnspentInputs(vaultAccountId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/vault/accounts/${vaultAccountId}/${assetId}/unspent_inputs`);
        });
    }
    /**
     * Generates a new address for an asset in a vault account
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset for which to generate the deposit address
     * @param description A description for the new address
     * @param customerRefId A customer reference ID
     * @param requestOptions
     */
    generateNewAddress(vaultAccountId, assetId, description, customerRefId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/vault/accounts/${vaultAccountId}/${assetId}/addresses`, {
                description,
                customerRefId
            }, requestOptions);
        });
    }
    /**
     * Sets the description of an existing address
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset
     * @param address The address for which to set the description
     * @param tag The XRP tag, or EOS memo, for which to set the description
     * @param description The description to set
     */
    setAddressDescription(vaultAccountId, assetId, address, tag, description) {
        return __awaiter(this, void 0, void 0, function* () {
            let addressId = address;
            if (tag && tag.length > 0) {
                addressId = `${address}:${tag}`;
            }
            return yield this.apiClient.issuePutRequest(`/v1/vault/accounts/${vaultAccountId}/${assetId}/addresses/${addressId}`, { description: description || "" });
        });
    }
    /**
     * Gets all network connections
     * @returns NetworkConnectionResponse
     */
    getNetworkConnections() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/network_connections");
        });
    }
    /**
     * Creates a network connection
     * @param localNetworkId The local netowrk profile's id
     * @param remoteNetworkId The remote network profile's id
     * @param routingPolicy The desired routing policy for the connection
     * @returns NetworkConnectionResponse
     */
    createNetworkConnection(localNetworkId, remoteNetworkId, routingPolicy) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { localNetworkId, remoteNetworkId, routingPolicy };
            return yield this.apiClient.issuePostRequest(`/v1/network_connections`, body);
        });
    }
    /**
     * Gets a single network connection
     * @param connectionId The network connection's id
     * @returns NetworkConnectionResponse
     */
    getNetworkConnectionById(connectionId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/network_connections/${connectionId}`);
        });
    }
    /**
     * Removes a network connection
     * @param connectionId The network connection's id
     * @returns OperationSuccessResponse
     */
    removeNetworkConnection(connectionId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/network_connections/${connectionId}`);
        });
    }
    /**
     * Sets routing policy for a network connection
     * @param connectionId The network connection's id
     * @param routingPolicy The desired routing policy
     */
    setNetworkConnectionRoutingPolicy(connectionId, routingPolicy) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { routingPolicy };
            return yield this.apiClient.issuePatchRequest(`/v1/network_connections/${connectionId}/set_routing_policy`, body);
        });
    }
    /**
     * Gets all discoverable network profiles
     * @returns NetworkIdResponse
     */
    getDiscoverableNetworkIds() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/network_ids`);
        });
    }
    /**
     * Creates a new network profile
     * @param name A name for the new network profile
     * @param routingPolicy The desired routing policy for the network
     * @returns NetworkConnectionResponse
     */
    createNetworkId(name, routingPolicy) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { name, routingPolicy };
            return yield this.apiClient.issuePostRequest(`/v1/network_ids`, body);
        });
    }
    /**
     * Gets a single network profile
     * @param networkId The network profile's id
     * @returns NetworkIdResponse
     */
    getNetworkId(networkId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/network_ids/${networkId}`);
        });
    }
    /**
     * Deletes a single network profile
     * @param networkId The network profile's id
     * @returns NetworkIdResponse
     */
    deleteNetworkId(networkId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/network_ids/${networkId}`);
        });
    }
    /**
     * Sets discoverability for network profile
     * @param networkId The network profile's id
     * @param isDiscoverable The desired discoverability to set
     * @returns OperationSuccessResponse
     */
    setNetworkIdDiscoverability(networkId, isDiscoverable) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { isDiscoverable };
            return yield this.apiClient.issuePatchRequest(`/v1/network_ids/${networkId}/set_discoverability`, body);
        });
    }
    /**
     * Sets routing policy for network profile
     * @param networkId The network profile's id
     * @param routingPolicy The desired routing policy
     * @returns OperationSuccessResponse
     */
    setNetworkIdRoutingPolicy(networkId, routingPolicy) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { routingPolicy };
            return yield this.apiClient.issuePatchRequest(`/v1/network_ids/${networkId}/set_routing_policy`, body);
        });
    }
    /**
     * Sets network profile name
     * @param networkId The network profile's id
     * @param name The desired network profile's name
     * @returns OperationSuccessResponse
     */
    setNetworkIdName(networkId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { name };
            return yield this.apiClient.issuePatchRequest(`/v1/network_ids/${networkId}/set_name`, body);
        });
    }
    /**
     * Gets all exchange accounts for your tenant
     */
    getExchangeAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/exchange_accounts");
        });
    }
    /**
     * Gets all exchange accounts for your tenant
     * @param filter Get exchange accounts matching pageFilter params
     */
    getExchangeAccountsPaged(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/exchange_accounts/paged?${query_string_1.default.stringify(filter)}`);
        });
    }
    /**
     * Gets a single exchange account by ID
     * @param exchangeAccountId The exchange account ID
     */
    getExchangeAccountById(exchangeAccountId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/exchange_accounts/${exchangeAccountId}`);
        });
    }
    /**
     * Gets a single asset within an Exchange Account
     * @param exchangeAccountId The exchange account ID
     * @param assetId The ID of the asset
     */
    getExchangeAsset(exchangeAccountId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/exchange_accounts/${exchangeAccountId}/${assetId}`);
        });
    }
    /**
     * Convert an asset at an Exchange Account
     * @param exchangeAccountId The exchange account ID
     * @param srcAsset The source asset to convert from
     * @param destAsset The destination asset to convert to
     * @param amount The amount to convert
     */
    convertExchangeAsset(exchangeAccountId, srcAsset, destAsset, amount, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/exchange_accounts/${exchangeAccountId}/convert`, {
                srcAsset, destAsset, amount
            }, requestOptions);
        });
    }
    /**
     * Transfer from a main exchange account to a subaccount
     * @param exchangeAccountId The exchange ID in Fireblocks
     * @param subaccountId The ID of the subaccount in the exchange
     * @param assetId The asset to transfer
     * @param amount The amount to transfer
     * @param requestOptions
     */
    transferToSubaccount(exchangeAccountId, subaccountId, assetId, amount, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                subaccountId,
                amount
            };
            return yield this.apiClient.issuePostRequest(`/v1/exchange_accounts/${exchangeAccountId}/${assetId}/transfer_to_subaccount`, body, requestOptions);
        });
    }
    /**
     * Transfer from a subaccount to a main exchange account
     * @param exchangeAccountId The exchange ID in Fireblocks
     * @param subaccountId The ID of the subaccount in the exchange
     * @param assetId The asset to transfer
     * @param amount The amount to transfer
     * @param requestOptions
     */
    transferFromSubaccount(exchangeAccountId, subaccountId, assetId, amount, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                subaccountId,
                amount
            };
            return yield this.apiClient.issuePostRequest(`/v1/exchange_accounts/${exchangeAccountId}/${assetId}/transfer_from_subaccount`, body, requestOptions);
        });
    }
    /**
     * Gets all fiat accounts for your tenant
     */
    getFiatAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/fiat_accounts");
        });
    }
    /**
     * Gets a single fiat account by ID
     * @param accountId The fiat account ID
     */
    getFiatAccountById(accountId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/fiat_accounts/${accountId}`);
        });
    }
    /**
     * Redeem from a fiat account to a linked DDA
     * @param accountId The fiat account ID in Fireblocks
     * @param amount The amount to transfer
     * @param requestOptions
     */
    redeemToLinkedDDA(accountId, amount, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                amount
            };
            return yield this.apiClient.issuePostRequest(`/v1/fiat_accounts/${accountId}/redeem_to_linked_dda`, body, requestOptions);
        });
    }
    /**
     * Deposit to a fiat account from a linked DDA
     * @param accountId The fiat account ID in Fireblocks
     * @param amount The amount to transfer
     * @param requestOptions
     */
    depositFromLinkedDDA(accountId, amount, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                amount
            };
            return yield this.apiClient.issuePostRequest(`/v1/fiat_accounts/${accountId}/deposit_from_linked_dda`, body, requestOptions);
        });
    }
    /**
     * Gets a list of transactions matching the given filter
     * @param filter.before Only gets transactions created before a given timestamp (in milliseconds)
     * @param filter.after Only gets transactions created after a given timestamp (in milliseconds)
     * @param filter.status Only gets transactions with the spcified status
     * @param filter.limit Limit the amount of returned results. If not specified, a limit of 200 results will be used
     * @param filter.orderBy Determines the order of the results
     */
    getTransactions(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/transactions?${query_string_1.default.stringify(filter)}`);
        });
    }
    /**
     * Gets a list of transactions per page matching the given filter or path
     * @param pageFilter Get transactions matching pageFilter params
     * @param nextOrPreviousPath Get transactions from each of pageDetails paths
     */
    getTransactionsWithPageInfo(pageFilter, nextOrPreviousPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (pageFilter) {
                return yield this.apiClient.issueGetRequestForTransactionPages(`/v1/transactions?${query_string_1.default.stringify(pageFilter)}`);
            }
            else if (nextOrPreviousPath) {
                const index = nextOrPreviousPath.indexOf("/v1/");
                const path = nextOrPreviousPath.substring(index, nextOrPreviousPath.length);
                return yield this.apiClient.issueGetRequestForTransactionPages(path);
            }
            return {
                transactions: [], pageDetails: { prevPage: "", nextPage: "" },
            };
        });
    }
    /**
     * Gets a transaction matching the external transaction id provided
     * @param externalTxId
     */
    getTransactionByExternalTxId(externalTxId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/transactions/external_tx_id/${externalTxId}`);
        });
    }
    /**
     * Gets all internal wallets for your tenant
     */
    getInternalWallets() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/internal_wallets");
        });
    }
    /**
     * Gets a single internal wallet
     * @param walletId The internal wallet ID
     */
    getInternalWallet(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/internal_wallets/${walletId}`);
        });
    }
    /**
     * Gets a paginated response of assets for a single internal wallet
     * @param walletId The internal wallet ID
     * @param pageSize Number of assets to return per page (default=50, max=200)
     * @param pageCursor Cursor for pagination
     */
    getInternalWalletAssets(walletId, pageSize, pageCursor) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/internal_wallets/${walletId}/assets`, { pageSize, pageCursor });
        });
    }
    /**
     * Gets a single internal wallet asset
     * @param walletId The internal wallet ID
     * @param assetId The asset ID
     */
    getInternalWalletAsset(walletId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/internal_wallets/${walletId}/${assetId}`);
        });
    }
    /**
     * Gets all external wallets for your tenant
     */
    getExternalWallets() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/external_wallets");
        });
    }
    /**
     * Gets a single external wallet
     * @param walletId The external wallet ID
     */
    getExternalWallet(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/external_wallets/${walletId}`);
        });
    }
    /**
     * Gets a single external wallet asset
     * @param walletId The external wallet ID
     * @param assetId The asset ID
     */
    getExternalWalletAsset(walletId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/external_wallets/${walletId}/${assetId}`);
        });
    }
    /**
     * Gets all contract wallets for your tenant
     */
    getContractWallets() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/contracts");
        });
    }
    /**
     * Gets a single contract wallet
     * @param walletId The contract wallet ID
     */
    getContractWallet(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/contracts/${walletId}`);
        });
    }
    /**
     * Gets a single contract wallet asset
     * @param walletId The contract wallet ID
     * @param assetId The asset ID
     */
    getContractWalletAsset(walletId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/contracts/${walletId}/${assetId}`);
        });
    }
    /**
     * Gets detailed information for a single transaction
     * @param txId The transaction id to query
     */
    getTransactionById(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/transactions/${txId}`);
        });
    }
    /**
     * Cancels the selected transaction
     * @param txId The transaction id to cancel
     * @param requestOptions
     */
    cancelTransactionById(txId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/transactions/${txId}/cancel`, {}, requestOptions);
        });
    }
    /**
     * Creates a new vault account
     * @param name A name for the new vault account
     * @param hiddenOnUI If true, the created account and all related transactions will not be shown on Fireblocks console
     * @param customerRefId A customer reference ID
     * @param autoFuel
     * @param requestOptions
     * @param autoFuel
     * @param requestOptions
     */
    createVaultAccount(name, hiddenOnUI, customerRefId, autoFuel, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                name,
                customerRefId,
                hiddenOnUI: hiddenOnUI || false,
                autoFuel: autoFuel || false
            };
            return yield this.apiClient.issuePostRequest("/v1/vault/accounts", body, requestOptions);
        });
    }
    /**
     * Hides a vault account in Fireblocks console
     * @param vaultAccountId The vault account ID
     * @param requestOptions
     */
    hideVaultAccount(vaultAccountId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/vault/accounts/${vaultAccountId}/hide`, {}, requestOptions);
        });
    }
    /**
     * Reveals a hidden vault account in Fireblocks console
     * @param vaultAccountId The vault account ID
     * @param requestOptions
     */
    unhideVaultAccount(vaultAccountId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/vault/accounts/${vaultAccountId}/unhide`, {}, requestOptions);
        });
    }
    /**
     * Sets autoFuel to true/false for a vault account
     * @param vaultAccountId The vault account ID
     * @param autoFuel The new value for the autoFuel flag
     * @param requestOptions
     */
    setAutoFuel(vaultAccountId, autoFuel, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/vault/accounts/${vaultAccountId}/set_auto_fuel`, { autoFuel }, requestOptions);
        });
    }
    /**
     * Updates a vault account
     * @param vaultAccountId
     * @param name A new name for the vault account
     */
    updateVaultAccount(vaultAccountId, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                name: name
            };
            return yield this.apiClient.issuePutRequest(`/v1/vault/accounts/${vaultAccountId}`, body);
        });
    }
    /**
     * Creates a new asset within an existing vault account
     * @param vaultAccountId The vault account ID
     * @param assetId The asset to add
     * @param requestOptions
     */
    createVaultAsset(vaultAccountId, assetId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/vault/accounts/${vaultAccountId}/${assetId}`, {}, requestOptions);
        });
    }
    /**
     * Registers new asset
     * @param blockchainId Native asset of blockchain
     * @param address Asset contract address
     * @param symbol Asset symbol
     * @param requestOptions
     */
    registerNewAsset(blockchainId, address, symbol, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/assets`, { blockchainId, address, symbol }, requestOptions);
        });
    }
    /**
     * List assets
     * @param filters
     */
    listAssets(filters) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/assets`, filters);
        });
    }
    /**
     * Get an asset
     * @param assetId The ID or legacyId of the asset
     */
    getAssetById(assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/assets/${assetId}`);
        });
    }
    /**
     * List blockchains
     * @param filters
     */
    listBlockchains(filters) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/blockchains`, filters);
        });
    }
    /**
     * Get an blockchain
     * @param blockchainId The ID or legacyId of the blockchain
     */
    getBlockchainById(blockchainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/blockchains/${blockchainId}`);
        });
    }
    /**
     * Retry to create a vault asset for a vault asset that failed
     * @param vaultAccountId The vault account ID
     * @param assetId The asset to add
     * @param requestOptions
     */
    activateVaultAsset(vaultAccountId, assetId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/vault/accounts/${vaultAccountId}/${assetId}/activate`, {}, requestOptions);
        });
    }
    /**
     * Creates a new external wallet
     * @param name A name for the new external wallet
     * @param customerRefId A customer reference ID
     * @param requestOptions
     */
    createExternalWallet(name, customerRefId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                name,
                customerRefId
            };
            return yield this.apiClient.issuePostRequest("/v1/external_wallets", body, requestOptions);
        });
    }
    /**
     * Creates a new internal wallet
     * @param name A name for the new internal wallet
     * @param customerRefId A customer reference ID
     * @param requestOptions
     */
    createInternalWallet(name, customerRefId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                name,
                customerRefId
            };
            return yield this.apiClient.issuePostRequest("/v1/internal_wallets", body, requestOptions);
        });
    }
    /**
     * Creates a new contract wallet
     * @param name A name for the new contract wallet
     */
    createContractWallet(name, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                name,
            };
            return yield this.apiClient.issuePostRequest("/v1/contracts", body, requestOptions);
        });
    }
    /**
     * Creates a new asset within an exiting external wallet
     * @param walletId The wallet id
     * @param assetId The asset to add
     * @param address The wallet address
     * @param tag (for ripple only) The ripple account tag
     * @param requestOptions
     */
    createExternalWalletAsset(walletId, assetId, address, tag, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/v1/external_wallets/${walletId}/${assetId}`;
            const body = {
                address: address,
                tag: tag
            };
            return yield this.apiClient.issuePostRequest(path, body, requestOptions);
        });
    }
    /**
     * Creates a new asset within an exiting internal wallet
     * @param walletId The wallet id
     * @param assetId The asset to add
     * @param address The wallet address
     * @param tag (for ripple only) The ripple account tag
     * @param requestOptions
     */
    createInternalWalletAsset(walletId, assetId, address, tag, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/v1/internal_wallets/${walletId}/${assetId}`;
            const body = {
                address: address,
                tag: tag
            };
            return yield this.apiClient.issuePostRequest(path, body, requestOptions);
        });
    }
    /**
     * Creates a new asset within an exiting contract wallet
     * @param walletId The wallet id
     * @param assetId The asset to add
     * @param address The wallet address
     * @param tag (for ripple only) The ripple account tag
     */
    createContractWalletAsset(walletId, assetId, address, tag, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = `/v1/contracts/${walletId}/${assetId}`;
            const body = {
                address: address,
                tag: tag
            };
            return yield this.apiClient.issuePostRequest(path, body, requestOptions);
        });
    }
    /**
     * Creates a new transaction with the specified options
     */
    createTransaction(transactionArguments, requestOptions, travelRuleEncryptionOptions) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const opts = Object.assign({}, requestOptions);
            if (transactionArguments === null || transactionArguments === void 0 ? void 0 : transactionArguments.travelRuleMessage) {
                transactionArguments = yield this.piiClient.hybridEncode(transactionArguments, travelRuleEncryptionOptions);
            }
            if (((_a = transactionArguments.source) === null || _a === void 0 ? void 0 : _a.type) === types_1.PeerType.END_USER_WALLET && !((_b = opts.ncw) === null || _b === void 0 ? void 0 : _b.walletId)) {
                const { walletId } = transactionArguments.source;
                opts.ncw = Object.assign(Object.assign({}, opts.ncw), { walletId });
            }
            return yield this.apiClient.issuePostRequest("/v1/transactions", transactionArguments, opts);
        });
    }
    /**
     * Estimates the fee for a transaction request
     */
    estimateFeeForTransaction(transactionArguments, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest("/v1/transactions/estimate_fee", transactionArguments, requestOptions);
        });
    }
    /**
     * Gets the estimated fees for an asset
     */
    getFeeForAsset(asset) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/estimate_network_fee?assetId=${asset}`);
        });
    }
    /**
     * Deletes a single internal wallet
     * @param walletId The internal wallet ID
     */
    deleteInternalWallet(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/internal_wallets/${walletId}`);
        });
    }
    /**
     * Deletes a single internal wallet asset
     * @param walletId The internal wallet ID
     * @param assetId The asset ID
     */
    deleteInternalWalletAsset(walletId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/internal_wallets/${walletId}/${assetId}`);
        });
    }
    /**
     * Deletes a single external wallet
     * @param walletId The external wallet ID
     */
    deleteExternalWallet(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/external_wallets/${walletId}`);
        });
    }
    /**
     * Deletes a single external wallet asset
     * @param walletId The external wallet ID
     * @param assetId The asset ID
     */
    deleteExternalWalletAsset(walletId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/external_wallets/${walletId}/${assetId}`);
        });
    }
    /**
     * Deletes a single contract wallet
     * @param walletId The contract wallet ID
     */
    deleteContractWallet(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/contracts/${walletId}`);
        });
    }
    /**
     * Deletes a single contract wallet asset
     * @param walletId The contract wallet ID
     * @param assetId The asset ID
     */
    deleteContractWalletAsset(walletId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/contracts/${walletId}/${assetId}`);
        });
    }
    /**
     * Sets a customer reference ID
     * @param vaultAccountId The vault account ID
     * @param customerRefId The customer reference ID to set
     * @param requestOptions
     */
    setCustomerRefIdForVaultAccount(vaultAccountId, customerRefId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/vault/accounts/${vaultAccountId}/set_customer_ref_id`, { customerRefId }, requestOptions);
        });
    }
    /**
     * Sets a customer reference ID
     * @param walletId The ID of the internal wallet
     * @param customerRefId The customer reference ID to set
     * @param requestOptions
     */
    setCustomerRefIdForInternalWallet(walletId, customerRefId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/internal_wallets/${walletId}/set_customer_ref_id`, { customerRefId }, requestOptions);
        });
    }
    /**
     * Sets a customer reference ID
     * @param walletId The ID of the external wallet
     * @param customerRefId The customer reference ID to set
     * @param requestOptions
     */
    setCustomerRefIdForExternalWallet(walletId, customerRefId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/external_wallets/${walletId}/set_customer_ref_id`, { customerRefId }, requestOptions);
        });
    }
    /**
     * Sets a customer reference ID
     * @param vaultAccountId The vault account ID
     * @param assetId The ID of the asset
     * @param address The address
     * @param tag The XRP tag, or EOS memo
     * @param customerRefId The customer reference ID to set
     * @param requestOptions
     */
    setCustomerRefIdForAddress(vaultAccountId, assetId, address, tag, customerRefId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            let addressId = address;
            if (tag && tag.length > 0) {
                addressId = `${address}:${tag}`;
            }
            return yield this.apiClient.issuePostRequest(`/v1/vault/accounts/${vaultAccountId}/${assetId}/addresses/${addressId}/set_customer_ref_id`, { customerRefId }, requestOptions);
        });
    }
    /**
     * Set the required number of confirmations for transaction
     * @param txId
     * @param requiredConfirmationsNumber
     * @param requestOptions
     */
    setConfirmationThresholdForTxId(txId, requiredConfirmationsNumber, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/transactions/${txId}/set_confirmation_threshold`, { numOfConfirmations: requiredConfirmationsNumber }, requestOptions);
        });
    }
    /**
     * Set the required number of confirmations for transactions by tx hash
     * @param txHash
     * @param requiredConfirmationsNumber
     * @param requestOptions
     */
    setConfirmationThresholdForTxHash(txHash, requiredConfirmationsNumber, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/txHash/${txHash}/set_confirmation_threshold`, { numOfConfirmations: requiredConfirmationsNumber }, requestOptions);
        });
    }
    /**
     * Get the public key information
     * @param args
     */
    getPublicKeyInfo(args) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, public_key_info_1.getPublicKeyInfoImpl)(types_1.PeerType.VAULT_ACCOUNT, args, this.apiClient);
        });
    }
    /**
     * allocate funds from you default balance to a private ledger
     * @param vaultAccountId
     * @param asset
     * @param vaultAccountId
     * @param asset
     * @param args
     * @param requestOptions
     */
    allocateFundsToPrivateLedger(vaultAccountId, asset, args, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `/v1/vault/accounts/${vaultAccountId}/${asset}/lock_allocation`;
            return yield this.apiClient.issuePostRequest(url, args, requestOptions);
        });
    }
    /**
     * deallocate funds from a private ledger to your default balance
     * @param vaultAccountId
     * @param asset
     * @param args
     * @param requestOptions
     */
    deallocateFundsFromPrivateLedger(vaultAccountId, asset, args, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `/v1/vault/accounts/${vaultAccountId}/${asset}/release_allocation`;
            return yield this.apiClient.issuePostRequest(url, args, requestOptions);
        });
    }
    /**
     * Get the public key information for a vault account
     * @param args
     */
    getPublicKeyInfoForVaultAccount(args) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, public_key_info_1.getPublicKeyInfoByAccountAssetImpl)(types_1.PeerType.VAULT_ACCOUNT, args, this.apiClient);
        });
    }
    /**
     * Get configuration and status of the Gas Station account
     */
    getGasStationInfo(assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `/v1/gas_station`;
            if (assetId) {
                url += `/${assetId}`;
            }
            return yield this.apiClient.issueGetRequest(url);
        });
    }
    /**
     * Set configuration of the Gas Station account
     */
    setGasStationConfiguration(gasThreshold, gasCap, maxGasPrice, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `/v1/gas_station/configuration`;
            if (assetId) {
                url += `/${assetId}`;
            }
            const body = { gasThreshold, gasCap, maxGasPrice };
            return yield this.apiClient.issuePutRequest(url, body);
        });
    }
    /**
     * Drop an ETH based transaction
     */
    dropTransaction(txId, feeLevel, requestedFee, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `/v1/transactions/${txId}/drop`;
            const body = { feeLevel, requestedFee };
            return yield this.apiClient.issuePostRequest(url, body, requestOptions);
        });
    }
    /**
     * Get max spendable amount per asset and vault
     */
    getMaxSpendableAmount(vaultAccountId, assetId, manualSigning) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `/v1/vault/accounts/${vaultAccountId}/${assetId}/max_spendable_amount`;
            if (manualSigning) {
                url += `?manualSigning=${manualSigning}`;
            }
            return yield this.apiClient.issueGetRequest(url);
        });
    }
    /**
     * Get maximum BIP44 index used in deriving addresses or in change addresses
     */
    getMaxBip44IndexUsed(vaultAccountId, assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `/v1/vault/accounts/${vaultAccountId}/${assetId}/max_bip44_index_used`;
            return yield this.apiClient.issueGetRequest(url);
        });
    }
    /**
     * Gets a paginated response of the addresses for a given vault account and asset
     */
    getPaginatedAddresses(vaultAccountId, assetId, paginatedAddressesRequestFilters) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/vault/accounts/${vaultAccountId}/${assetId}/addresses_paginated?${query_string_1.default.stringify(paginatedAddressesRequestFilters)}`);
        });
    }
    /**
     * Get all vault assets balance overview
     */
    getVaultAssetsBalance(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `/v1/vault/assets?${query_string_1.default.stringify(filter)}`;
            return yield this.apiClient.issueGetRequest(url);
        });
    }
    /**
     * Get vault balance overview per asset
     */
    getVaultBalanceByAsset(assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `/v1/vault/assets/${assetId}`;
            return yield this.apiClient.issueGetRequest(url);
        });
    }
    /**
     * Get address validation info
     */
    validateAddress(assetId, address) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `/v1/transactions/validate_address/${assetId}/${address}`;
            return yield this.apiClient.issueGetRequest(url);
        });
    }
    /**
     * Unfreezes the selected transaction
     * @param txId The transaction id to unfreeze
     * @param requestOptions
     */
    unfreezeTransactionById(txId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiClient.issuePostRequest(`/v1/transactions/${txId}/unfreeze`, {}, requestOptions);
        });
    }
    /**
     * Freezes the selected transaction
     * @param txId The transaction id to freeze
     * @param requestOptions
     */
    freezeTransactionById(txId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiClient.issuePostRequest(`/v1/transactions/${txId}/freeze`, {}, requestOptions);
        });
    }
    /**
     * Resend failed webhooks
     */
    resendWebhooks(requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest("/v1/webhooks/resend", {}, requestOptions);
        });
    }
    /**
     * Resend transaction webhooks
     * @param txId The transaction for which the message is sent
     * @param resendCreated If true a webhook will be sent for the creation of the transaction
     * @param resendStatusUpdated If true a webhook will be sent for the status of the transaction
     * @param requestOptions
     */
    resendTransactionWebhooksById(txId, resendCreated, resendStatusUpdated, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { resendCreated, resendStatusUpdated };
            return yield this.apiClient.issuePostRequest(`/v1/webhooks/resend/${txId}`, body, requestOptions);
        });
    }
    /**
     * Gets all Users for your tenant
     */
    getUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/users");
        });
    }
    /**
     * Gets all Console Users for your tenant
     */
    getConsoleUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/management/users");
        });
    }
    /**
     * Gets all Api Users for your tenant
     */
    getApiUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/management/api_users");
        });
    }
    /**
     * Create Console User for your tenant
     * @param firstName firstName of the user, example: "Johnny".  Maximum length: 30 chars.
     * @param lastName lastName of the user. Maximum length: 30 chars.
     * @param email email of the user, example: "email@example.com"
     * @param role role of the user, for example: "ADMIN"
     * @param requestOptions
     */
    createConsoleUser(firstName, lastName, email, role, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { firstName, lastName, email, role };
            return yield this.apiClient.issuePostRequest("/v1/management/users", body, requestOptions);
        });
    }
    /**
     * Create Api User for your tenant
     * @param name name of the api user, example: "Johnny The Api".  Maximum length: 30 chars.
     * @param role role of the user, for example: "ADMIN"
     * @param csrPem generate .csr file and provide its string content here, example:  "-----BEGIN CERTIFICATE REQUEST-----aaa-----END CERTIFICATE REQUEST-----"
     * You can find more info about csrPem and how to create it here: https://developers.fireblocks.com/docs/quickstart
     * @param coSignerSetup your cosigner, for example: "SGX_MACHINE", read more: https://developers.fireblocks.com/docs/quickstart
     * @param coSignerSetupIsFirstUser [SGX server enabled only] If you are the first user to be configured on this SGX-enabled Co-Signer server, this has to be true
     */
    createApiUser(name, role, csrPem, coSignerSetup, coSignerSetupIsFirstUser, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { name, role, csrPem, coSignerSetup, coSignerSetupIsFirstUser };
            return yield this.apiClient.issuePostRequest("/v1/management/api_users", body, requestOptions);
        });
    }
    /**
     * Re-enroll Mobile Device of a user in your tenant
     * @param id userId of the user to reset device
     * @param requestOptions
     */
    resetDeviceRequest(id, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/management/users/${id}/reset_device`, {}, requestOptions);
        });
    }
    /**
     * Get whitelisted addresses of api user in your tenant
     * @param id userId of the user
     * @param requestOptions
     */
    getWhitelistedAddresses(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/management/api_users/${id}/whitelist_ip_addresses`);
        });
    }
    /**
     * Get the tenant's OTA (One-Time-Address) configuration
     */
    getOtaConfiguration() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/management/ota");
        });
    }
    /**
     * Update the tenant's OTA (One-Time-Address) configuration
     * @param enable
     */
    updateOtaConfiguration(enable) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { enabled: enable };
            return yield this.apiClient.issuePutRequest("/v1/management/ota", body);
        });
    }
    /** Gets all Users Groups for your tenant
     */
    getUserGroups() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/management/user_groups");
        });
    }
    /**
     * Gets a Users Group by ID
     * @param id The ID of the User
     */
    getUserGroup(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/management/user_groups/${id}`);
        });
    }
    /**
     * Creates a new Users Group
     * @param name The name of the Users Group
     * @param memberIds The members of the Users Group
     */
    createUserGroup(groupName, memberIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { groupName, memberIds };
            return yield this.apiClient.issuePostRequest("/v1/management/user_groups", body);
        });
    }
    /**
     * Updates a Users Group
     * @param id The ID of the Users Group
     * @param name The name of the Users Group
     * @param memberIds The members of the Users Group
     */
    updateUserGroup(id, groupName, memberIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = { groupName, memberIds };
            return yield this.apiClient.issuePutRequest(`/v1/management/user_groups/${id}`, body);
        });
    }
    /**
     * Deletes a Users Group
     * @param id The ID of the Users Group
     */
    deleteUserGroup(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/management/user_groups/${id}`);
        });
    }
    /**
     * Get off exchange accounts
     */
    getOffExchangeAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/off_exchange_accounts`);
        });
    }
    /**
     * Get off exchange account by virtual account id
     * @param id the ID of the off exchange
     */
    getOffExchangeAccountById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/off_exchange_accounts/${id}`);
        });
    }
    /**
     * Settle off exchange account by virtual account id
     * @param id the ID of the off exchange
     * @param requestOptions
     */
    settleOffExchangeAccountById(id, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/off_exchange_accounts/${id}/settle`, {}, requestOptions);
        });
    }
    /**
     * Add collateral account, create deposit request
     * @param depositRequest
     * @param requestOptions
     */
    addCollateral(depositRequest, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/off_exchange/add`, depositRequest, requestOptions);
        });
    }
    /**
     * Remove collateral account, create withdraw request
     * @param withdrawRequest
     * @param requestOptions
     */
    removeCollateral(withdrawRequest, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/off_exchange/remove`, withdrawRequest, requestOptions);
        });
    }
    /**
     *
     * @param requestOptions
     */
    getSettlementTransactions(settlementRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/off_exchange/settlements/transactions?mainExchangeAccountId=${settlementRequest.mainExchangeAccountId}`);
        });
    }
    /**
     *
     * @param settlementRequest
     * @param requestOptions
     */
    settlement(settlementRequest, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/off_exchange/settlements/trader`, settlementRequest, requestOptions);
        });
    }
    /**
     * Set Fee Payer configuration
     * @param feePayerConfiguration
     * @param baseAsset
     * @param requestOptions
     */
    setFeePayerConfiguration(baseAsset, feePayerConfiguration, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/fee_payer/${baseAsset}`, feePayerConfiguration, requestOptions);
        });
    }
    /**
     * Get Fee Payer Configuration
     * @param baseAsset
     */
    getFeePayerConfiguration(baseAsset) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/fee_payer/${baseAsset}`);
        });
    }
    /**
     * Delete Fee Payer Configuration
     * @param baseAsset
     */
    removeFeePayerConfiguration(baseAsset) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/fee_payer/${baseAsset}`);
        });
    }
    getWeb3ConnectionPath(type) {
        const basePath = `/v1/connections`;
        switch (type) {
            case (types_1.Web3ConnectionType.WALLET_CONNECT): {
                return `${basePath}/wc`;
            }
            default: {
                throw new Error(`Invalid Web3 connection type`);
            }
        }
    }
    /**
     * Get all signer connections of the current tenant
     * @param {Object} payload The payload for getting the current tenant's sessions
     * @param payload.pageCursor The cursor for the next page
     * @param payload.pageSize The amount of results to return on the next page
     * @param payload.sort The property to sort the results by
     * @param payload.filter The filter object, containing properties as keys and the values to filter by as values
     * @param payload.order Should the results be ordered in ascending order (false) or descending (true)
     *
     * @returns An object containing the data returned and the cursor for the next page
     */
    getWeb3Connections({ pageCursor, pageSize, sort, filter, order, } = {}, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = new URLSearchParams(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (pageCursor && { next: pageCursor })), (pageSize && { pageSize: pageSize.toString() })), (sort && { sort })), (filter && { filter: (0, qs_1.stringify)(filter, { delimiter: "," }) })), (order && { order })));
            return yield this.apiClient.issueGetRequest(`/v1/connections?${params.toString()}`, undefined, requestOptions);
        });
    }
    createWeb3Connection(type, payload, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = this.getWeb3ConnectionPath(type);
            return yield this.apiClient.issuePostRequest(path, payload, requestOptions);
        });
    }
    submitWeb3Connection(type, sessionId, approve, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = this.getWeb3ConnectionPath(type);
            return yield this.apiClient.issuePutRequest(`${path}/${sessionId}`, { approve }, requestOptions);
        });
    }
    removeWeb3Connection(type, sessionId, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = this.getWeb3ConnectionPath(type);
            return yield this.apiClient.issueDeleteRequest(`${path}/${sessionId}`, requestOptions);
        });
    }
    /**
     * Gets all audits for selected time period
     * @param timePeriod
     * @param cursor
     */
    getAudits(timePeriod) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParams = {
                timePeriod,
            };
            return yield this.apiClient.issueGetRequest(`/v1/audits?${query_string_1.default.stringify(queryParams)}`);
        });
    }
    /**
     * Gets paginated audit logs for selected time period
     * @param timePeriod
     * @param cursor
     */
    getPaginatedAuditLogs(timePeriod, cursor) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParams = {
                timePeriod,
                cursor,
            };
            return yield this.apiClient.issueGetRequest(`/v1/management/audit_logs?${query_string_1.default.stringify(queryParams)}`);
        });
    }
    /**
     *
     * @param id
     */
    getNFT(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/nfts/tokens/${id}`);
        });
    }
    /**
     * @param {Object} payload
     * @param payload.pageCursor
     * @param payload.pageSize
     * @param payload.ids
     * @param payload.sort
     * @param payload.order
     */
    getNFTs({ pageCursor, pageSize, ids, sort, order }) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParams = {
                pageCursor,
                pageSize,
                ids: this.getCommaSeparatedList(ids),
                sort: this.getCommaSeparatedList(sort),
                order,
            };
            return yield this.apiClient.issueGetRequest(`/v1/nfts/tokens?${query_string_1.default.stringify(queryParams)}`);
        });
    }
    /**
     *
     * Gets a list of owned NFT tokens
     * @param filter.vaultAccountIds List of vault account IDs
     * @param filter.blockchainDescriptor The blockchain descriptor (based on legacy asset)
     * @param filter.collectionIds List of collection IDs
     * @param filter.ids List of token ids to fetch
     * @param filter.pageCursor Page cursor
     * @param filter.pageSize Page size
     * @param filter.sort Sort by value
     * @param filter.order Order value
     * @param filter.status Status (LISTED, ARCHIVED)
     * @param filter.search Search filter
     * @param filter.ncwAccountIds List of Non-Custodial wallet account IDs
     * @param filter.ncwId Non-Custodial wallet id
     * @param filter.walletType Wallet type (VAULT_ACCOUNT, END_USER_WALLET)
     * @param filter.spam Spam filter (true, false, all)
     */
    getOwnedNFTs(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = "/v1/nfts/ownership/tokens";
            if (filter) {
                const { blockchainDescriptor, vaultAccountIds, collectionIds, ids, pageCursor, pageSize, sort, order, status, search, ncwId, ncwAccountIds, walletType, spam } = filter;
                const requestFilter = {
                    vaultAccountIds: this.getCommaSeparatedList(vaultAccountIds),
                    blockchainDescriptor,
                    collectionIds: this.getCommaSeparatedList(collectionIds),
                    pageCursor,
                    pageSize,
                    ids: this.getCommaSeparatedList(ids),
                    sort: this.getCommaSeparatedList(sort),
                    order,
                    status,
                    search,
                    ncwId,
                    ncwAccountIds,
                    walletType,
                    spam,
                };
                url += `?${query_string_1.default.stringify(requestFilter)}`;
            }
            return yield this.apiClient.issueGetRequest(url);
        });
    }
    /**
     *
     * Get a list of owned NFT collections
     * @param filter.search Search by value
     * @param filter.status Status (LISTED, ARCHIVED)
     * @param filter.ncwId Non-Custodial wallet id
     * @param filter.walletType Wallet type (VAULT_ACCOUNT, END_USER_WALLET)
     * @param filter.pageCursor Page cursor
     * @param filter.pageSize Page size
     * @param filter.sort Sort by value
     * @param filter.order Order by value
     */
    listOwnedCollections(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = "/v1/nfts/ownership/collections";
            if (filter) {
                const { search, status, ncwId, walletType, pageCursor, pageSize, sort, order } = filter;
                const requestFilter = {
                    search,
                    status,
                    ncwId,
                    walletType,
                    pageCursor,
                    pageSize,
                    sort: this.getCommaSeparatedList(sort),
                    order,
                };
                url += `?${query_string_1.default.stringify(requestFilter)}`;
            }
            return yield this.apiClient.issueGetRequest(url);
        });
    }
    /**
     *
     * Get a list of owned tokens
     * @param filter.search Search by value
     * @param filter.status Status (LISTED, ARCHIVED)
     * @param filter.ncwId Non-Custodial wallet id
     * @param filter.walletType Wallet type (VAULT_ACCOUNT, END_USER_WALLET)
     * @param filter.pageCursor Page cursor
     * @param filter.pageSize Page size
     * @param filter.sort Sort by value
     * @param filter.order Order by value
     * @param filter.spam Spam filter (true, false, all)
     */
    listOwnedAssets(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = "/v1/nfts/ownership/assets";
            if (filter) {
                const { search, status, ncwId, walletType, pageCursor, pageSize, sort, order, spam } = filter;
                const requestFilter = {
                    search,
                    status,
                    ncwId,
                    walletType,
                    pageCursor,
                    pageSize,
                    sort: this.getCommaSeparatedList(sort),
                    order,
                    spam,
                };
                url += `?${query_string_1.default.stringify(requestFilter)}`;
            }
            return yield this.apiClient.issueGetRequest(url);
        });
    }
    /**
     *
     * @param id
     */
    refreshNFTMetadata(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePutRequest(`/v1/nfts/tokens/${id}`, undefined);
        });
    }
    /**
     *
     * Update NFT ownership status for specific token
     * @param id NFT asset id
     * @param status Status for update
     */
    updateNFTOwnershipStatus(id, status) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePutRequest(`/v1/nfts/ownership/tokens/${id}/status`, { status });
        });
    }
    /**
     *
     * Updates tokens status for a tenant, in all tenant vaults.
     * @param payload List of assets with status for update
     */
    updateNFTOwnershipsStatus(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePutRequest(`/v1/nfts/ownership/tokens/status`, payload);
        });
    }
    /**
     *
     * @param vaultAccountId
     * @param blockchainDescriptor
     */
    refreshNFTOwnershipByVault(vaultAccountId, blockchainDescriptor) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePutRequest(`/v1/nfts/ownership/tokens?vaultAccountId=${vaultAccountId}&blockchainDescriptor=${blockchainDescriptor}`, undefined);
        });
    }
    /**
     *
     * @param payload.assetId NFT asset id
     * @param payload.spam Spam status
     */
    updateNFTTokenOwnershipSpamStatus(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePutRequest(`/v1/nfts/ownership/tokens/spam`, payload);
        });
    }
    /**
     * Get all contract templates
     * @param {Object} payload The payload for getting the current tenant's sessions
     * @param {ContractInitializationPhase} payload.initializationPhase The contract initialization phase
     * @param {ContractTemplateType} payload.type The type of the contract templates you wish to retrieve. May contain more than one type
     * @param {number} payload.pageSize The amount of results to return on the next page
     * @param {string} payload.pageCursor The cursor for the next page
     *
     * @returns {LeanContractTemplateDto[]} A paginated array of contract templates
     */
    getContractTemplates({ initializationPhase, type, pageSize = DEFAULT_MAX_PAGE_SIZE, pageCursor } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tokenization/templates`, {
                initializationPhase,
                type,
                pageSize,
                pageCursor
            });
        });
    }
    /**
     * Upload a new contract. This contract would be private and only your tenant can see it
     * @param payload
     *
     * @returns {ContractTemplateDto}
     */
    uploadContractTemplate(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tokenization/templates`, payload);
        });
    }
    /**
     * Get contract template by id
     * @param templateId
     *
     * @returns {ContractTemplateDto}
     */
    getContractTemplate(templateId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tokenization/templates/${templateId}`);
        });
    }
    /**
     * Delete a contract template by id
     * @param templateId
     */
    deleteContractTemplate(templateId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueDeleteRequest(`/v1/tokenization/templates/${templateId}`);
        });
    }
    /**
     * Get contract template deploy function by id
     * @param templateId
     * @param withDocs
     *
     * @returns {AbiFunction}
     */
    getContractTemplateDeployFunction(templateId, withDocs = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tokenization/templates/${templateId}/deploy_function?withDocs=${withDocs}`);
        });
    }
    /**
     * Deploy a new contract by contract template id
     * @param templateId
     *
     * @returns {ContractDeployResponse}
     */
    deployContract(templateId, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tokenization/templates/${templateId}/deploy`, payload);
        });
    }
    /**
     * Get supported blockchains by template id
     * @param templateId
     *
     * @returns {SupportedBlockchainsResponse}
     */
    getSupportedBlockchains(templateId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tokenization/templates/${templateId}/supported_blockchains`);
        });
    }
    /**
     * Get all contracts by blockchain and template
     * @param blockchainId
     * @param contractTemplateId
     *
     * @returns {LeanDeployedContractResponseDto[]}
     */
    getContractsByFilter({ contractTemplateId, baseAssetId, contractAddress, pageSize = DEFAULT_MAX_PAGE_SIZE, pageCursor } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tokenization/contracts`, {
                contractTemplateId,
                baseAssetId,
                contractAddress,
                pageSize,
                pageCursor,
            });
        });
    }
    /**
     * Get contract ABI function by contractId
     * @param contractId
     * @param functionSignature
     *
     * @returns {AbiFunction}
     */
    getContractAbiFunction(contractId, functionSignature) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/contract-service/contract/${contractId}/function`, {
                functionSignature
            });
        });
    }
    /**
     * Get contract's address by blockchain base assetId and the transaction hash
     * @param baseAssetId
     * @param txHash
     *
     * @returns {ContractAddressResponseDto}
     */
    getContractAddress(baseAssetId, txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/contract_interactions/base_asset_id/${baseAssetId}/tx_hash/${txHash}`);
        });
    }
    /**
     * Get contract by blockchain base assetId and contract address
     * @param baseAssetId
     * @param templateId
     *
     * @returns {DeployedContractResponseDto}
     */
    getContractByAddress(baseAssetId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/contract_interactions/base_asset_id/${baseAssetId}/contract_address/${contractAddress}`);
        });
    }
    /**
     * Get contract's ABI by blockchain base assetId and contract address
     * @param baseAssetId
     * @param contractAddress
     *
     * @returns {ContractAbiResponseDto}
     */
    getContractAbi(baseAssetId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/contract_interactions/base_asset_id/${baseAssetId}/contract_address/${contractAddress}/functions`);
        });
    }
    /**
     * Fetch the ABI. If not found fetch the ABI from the block explorer
     * @param baseAssetId
     * @param contractAddress
     *
     * @returns {ContractWithABIDto}
     */
    fetchOrScrapeABI(baseAssetId, contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tokenization/contracts/fetch_abi`, {
                baseAssetId,
                contractAddress
            });
        });
    }
    /**
     * Save contract ABI for the tenant
     * @param baseAssetId
     * @param contractAddress
     * @param abi
     * @param name
     *
     * @returns {ContractWithABIDto}
     */
    saveABI(baseAssetId, contractAddress, abi, name) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tokenization/contracts/abi`, {
                baseAssetId,
                contractAddress,
                abi,
                name
            });
        });
    }
    /**
     * Get transaction receipt by blockchain base assetId and transaction hash
     * @param baseAssetId
     * @param txHash
     *
     * @returns TransactionReceiptResponseDto
     */
    getTransactionReceipt(baseAssetId, txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/contract_interactions/base_asset_id/${baseAssetId}/tx_hash/${txHash}/receipt`);
        });
    }
    /**
     * Call contract read function by blockchain base assetId and contract address
     * @param baseAssetId
     * @param templateId
     *
     * @returns ParameterWithValueList
     */
    readContractCallFunction(baseAssetId, contractAddress, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/contract_interactions/base_asset_id/${baseAssetId}/contract_address/${contractAddress}/functions/read`, payload);
        });
    }
    /**
     * Call contract write function by blockchain base assetId and contract address
     * @param baseAssetId
     * @param templateId
     *
     * @returns WriteCallFunctionResponseDto
     */
    writeContractCallFunction(baseAssetId, contractAddress, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/contract_interactions/base_asset_id/${baseAssetId}/contract_address/${contractAddress}/functions/write`, payload);
        });
    }
    /**
     * Creates a new asset and links it as a token.
     *
     * @param {IssueTokenRequest} payload - The payload containing information for token issuance.
     *
     * @returns {TokenLink} Response with created token ID
     */
    issueNewToken(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tokenization/tokens`, payload);
        });
    }
    /**
     * Retrieves all linked tokens in a paginated format.
     *
     * @param {Object} payload
     * @param {TokenLinkStatus} payload.status - The status of linked tokens (COMPLETED / PENDING). Default is COMPLETED
     * @param {number} payload.pageSize - The number of results to return on the next page
     * @param {string} payload.pageCursor - The cursor for the next page
     *
     * @returns {TokenLink[]} A paginated array of linked tokens
     */
    getLinkedTokens({ status, pageSize = DEFAULT_MAX_PAGE_SIZE, pageCursor } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tokenization/tokens`, {
                status,
                pageSize,
                pageCursor,
            });
        });
    }
    /**
     * Get the total count of linked tokens
     * @returns TokenLinksCount
     */
    getLinkedTokensCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tokenization/tokens/count`);
        });
    }
    /**
     * Link a token by refId to the tenant
     * @param type
     * @param refId
     * @param displayName
     *
     * @returns TokenLink
     */
    linkToken(type, refId, displayName) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tokenization/tokens/link`, { type, refId, displayName });
        });
    }
    /**
     * Link a token by baseAssetId and contract address to the tenant
     * @param type
     * @param baseAssetId
     * @param contractAddress
     * @param displayName
     *
     * @returns TokenLink
     */
    linkContractByAddress(type, baseAssetId, contractAddress, displayName) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tokenization/tokens/link`, { type, baseAssetId, contractAddress, displayName });
        });
    }
    /**
     * Get a linked token
     * @param id
     *
     * @returns TokenLink
     */
    getLinkedToken(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tokenization/tokens/${id}`);
        });
    }
    /**
     * Delete a token link
     * @param id
     */
    unlinkToken(id) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.apiClient.issueDeleteRequest(`/v1/tokenization/tokens/${id}`);
        });
    }
    /**
     * Retrieves all pending linked tokens in a paginated format
     *
     * @param {Object} payload - The payload for retrieving pending linked tokens
     * @param {number} payload.pageSize - The number of results to return on the next page
     * @param {string} payload.pageCursor - The cursor for the next page
     *
     * @returns {TokenLink[]} A paginated array of pending linked tokens
     */
    getPendingLinkedTokens({ pageSize, pageCursor } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getLinkedTokens({ status: types_1.TokenLinkStatus.PENDING, pageSize, pageCursor });
        });
    }
    /**
     * Creates a new collection and links it
     *
     * @param {CreateCollectionRequest} payload - The payload containing information for collection creation
     *
     * @returns {CollectionLink} Response with created collection link ID
     */
    createNewCollection(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tokenization/collections`, payload);
        });
    }
    /**
     * Retrieves all linked collections in a paginated format.
     *
     * @param {Object} payload
     * @param {TokenLinkStatus} payload.status - The status of linked collections (COMPLETED / PENDING). Default is COMPLETED
     * @param {number} payload.pageSize - The number of results to return on the next page
     * @param {string} payload.pageCursor - The cursor for the next page
     *
     * @returns {CollectionLink[]} A paginated array of linked collections
     */
    getLinkedCollections({ status, pageSize = DEFAULT_MAX_PAGE_SIZE, pageCursor } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest("/v1/tokenization/collections", {
                status,
                pageSize,
                pageCursor,
            });
        });
    }
    /**
     * Get a linked collection
     *
     * @returns CollectionLink
     */
    getLinkedCollection(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tokenization/collections/${id}`);
        });
    }
    /**
     * Unlink a collection
     */
    unlinkCollection(id) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.apiClient.issueDeleteRequest(`/v1/tokenization/collections/${id}`);
        });
    }
    /**
     * Mint collection NFT
     *
     * @returns WriteCallFunctionResponseDto
     */
    mintNFT(collectionId, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tokenization/collections/${collectionId}/tokens/mint`, payload);
        });
    }
    /**
     * Burn collection NFT
     *
     * @returns WriteCallFunctionResponseDto
     */
    burnNFT(collectionId, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tokenization/collections/${collectionId}/tokens/burn`, payload);
        });
    }
    /**
     * Get collection token details
     *
     * @returns CollectionTokenResponseDto
     */
    getLinkedCollectionTokenDetails(collectionId, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tokenization/collections/${collectionId}/tokens/${tokenId}`);
        });
    }
    /**
     * Validate VASP details for travel rule compliance
     * @param travelRuleMessageVaspInfo
     */
    validateTravelRuleTransaction(travelRuleMessageVaspInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/screening/travel_rule/transaction/validate`, travelRuleMessageVaspInfo);
        });
    }
    /**
     * Validate Travel Rule transaction and PII data
     * @param travelRuleMessage
     */
    validateFullTravelRuleTransaction(travelRuleMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/screening/travel_rule/transaction/validate/full`, travelRuleMessage);
        });
    }
    /**
     * Get VASP details for travel rule compliance
     * @param did
     */
    getTravelRuleVASPDetails(did) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/screening/travel_rule/vasp/${did}`);
        });
    }
    /**
     * Get VASP library for travel rule compliance
     */
    getAllTravelRuleVASPs(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `/v1/screening/travel_rule/vasp`;
            if (filter) {
                const { q, fields, page, per_page, order } = filter;
                const queryParameters = {
                    q,
                    fields: this.getCommaSeparatedList(fields),
                    page,
                    per_page,
                    order,
                };
                url += `?${query_string_1.default.stringify(queryParameters)}`;
            }
            return yield this.apiClient.issueGetRequest(url);
        });
    }
    /**
     * Update VASP for travel rule compliance
     */
    updateVasp(vaspInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePutRequest(`/v1/screening/travel-rule/vasp/update`, vaspInfo);
        });
    }
    /**
     * Get assigned VASP Did for a specific vault. Returns empty string vaspDid value in response if none assigned.
     */
    getVaspForVault(vaultAccountId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/screening/travel_rule/vault/${vaultAccountId.toString()}/vasp`);
        });
    }
    /**
     * Sets the VASP Did for a specific vault. Pass empty string to remove existing one.
     */
    setVaspForVault(vaultAccountId, vaspDid) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/screening/travel_rule/vault/${vaultAccountId.toString()}/vasp`, {
                vaspDid
            });
        });
    }
    /**
     * Get PostScreening Policies for compliance
     * @param screeningType The type of screening (e.g., 'travel_rule', 'aml')
     */
    getPostScreeningPolicy(screeningType) {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = `/v1/screening/${screeningType}/post_screening_policy`;
            return yield this.apiClient.issueGetRequest(endpoint);
        });
    }
    /**
     * Get Screening Policies for compliance
     * @param screeningType The type of screening (e.g., 'travel_rule', 'aml')
     */
    getScreeningPolicy(screeningType) {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = `/v1/screening/${screeningType}/screening_policy`;
            return yield this.apiClient.issueGetRequest(endpoint);
        });
    }
    /**
     * Get Screening Configuration for compliance
     * @param screeningType The type of screening (e.g., 'travel_rule', 'aml')
     */
    getScreeningConfiguration(screeningType) {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = `/v1/screening/${screeningType}/policy_configuration`;
            return yield this.apiClient.issueGetRequest(endpoint);
        });
    }
    /**
     * Update Bypass Screening Configuration for compliance
     * @param screeningType The type of screening (e.g., 'travel_rule', 'aml')
     * @param screeningPolicyConfiguration The configuration to update
     */
    updatePolicyConfiguration(screeningType, screeningPolicyConfiguration) {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = `/v1/screening/${screeningType}/policy_configuration`;
            return yield this.apiClient.issuePutRequest(endpoint, screeningPolicyConfiguration);
        });
    }
    /**
     * Update Bypass Screening Tenant Configuration for AML/KYT compliance
     * @param screeningTenantConfiguration
     */
    updateTenantScreeningConfiguration(screeningTenantConfiguration) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePutRequest(`/v1/screening/config`, screeningTenantConfiguration);
        });
    }
    /**
     * Get supported assets for screening per provider
     * @param provider The provider to get supported assets for
     */
    getSupportedAssetsForScreening(provider) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/screening/supported_assets/${provider}`);
        });
    }
    /**
     * Creates Smart Transfers ticket
     * @param data
     * @param requestOptions
     */
    createSmartTransferTicket(data, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/smart-transfers`, data, requestOptions);
        });
    }
    /**
     * Get Smart Transfer tickets
     * @param filters
     */
    getSmartTransferTickets(filters) {
        return this.apiClient.issueGetRequest(`/v1/smart-transfers?${query_string_1.default.stringify(filters)}`);
    }
    /**
     * Get Smart Transfers ticket by id
     * @param ticketId
     */
    getSmartTransferTicket(ticketId) {
        return this.apiClient.issueGetRequest(`/v1/smart-transfers/${ticketId}`);
    }
    /**
     * Set Smart Transfers ticket expires in
     * @param ticketId
     * @param expiresIn
     */
    setSmartTransferTicketExpiresIn(ticketId, expiresIn) {
        return this.apiClient.issuePutRequest(`/v1/smart-transfers/${ticketId}/expires-in`, { expiresIn });
    }
    /**
     * Set Smart Transfer ticket external id
     * @param ticketId
     * @param externalRefId
     */
    setSmartTransferTicketExternalId(ticketId, externalRefId) {
        return this.apiClient.issuePutRequest(`/v1/smart-transfers/${ticketId}/external-id`, { externalRefId });
    }
    /**
     * Submit Smart Transfers ticket
     * @param ticketId
     * @param expiresIn
     */
    submitSmartTransferTicket(ticketId, expiresIn) {
        return this.apiClient.issuePutRequest(`/v1/smart-transfers/${ticketId}/submit`, { expiresIn });
    }
    /**
     * Fulfill Smart Transfers ticket
     * @param ticketId
     */
    fulfillSmartTransferTicket(ticketId) {
        return this.apiClient.issuePutRequest(`/v1/smart-transfers/${ticketId}/fulfill`, {});
    }
    /**
     * Cancel Smart Transfers ticket
     * @param ticketId
     */
    cancelSmartTransferTicket(ticketId) {
        return this.apiClient.issuePutRequest(`/v1/smart-transfers/${ticketId}/cancel`, {});
    }
    /**
     * Create Smart Transfers ticket term
     * @param ticketId
     * @param data
     */
    createSmartTransferTicketTerm(ticketId, data) {
        return this.apiClient.issuePostRequest(`/v1/smart-transfers/${ticketId}/terms`, data);
    }
    /**
     * Fet Smart Transfers ticket term
     * @param ticketId
     * @param termId
     */
    getSmartTransferTicketTerms(ticketId, termId) {
        return this.apiClient.issueGetRequest(`/v1/smart-transfers/${ticketId}/terms/${termId}`);
    }
    /**
     * Update Smart Transfers ticket term
     * @param ticketId
     * @param termId
     * @param data
     */
    updateSmartTransferTicketTerms(ticketId, termId, data) {
        return this.apiClient.issuePutRequest(`/v1/smart-transfers/${ticketId}/terms/${termId}`, data);
    }
    /**
     * Fund Smart Transfers ticket term
     * @param ticketId
     * @param termId
     * @param data
     */
    fundSmartTransferTicketTerm(ticketId, termId, data) {
        return this.apiClient.issuePutRequest(`/v1/smart-transfers/${ticketId}/terms/${termId}/fund`, data);
    }
    /**
     * Manually fund Smart Transfers ticket term
     * @param ticketId
     * @param termId
     * @param txHash
     */
    manuallyFundSmartTransferTicketTerms(ticketId, termId, txHash) {
        return this.apiClient.issuePutRequest(`/v1/smart-transfers/${ticketId}/terms/${termId}/manually-fund`, { txHash });
    }
    /**
     * Set Smart Transfers user group ids. User group ids are used for Smart Transfer notifications
     * @param userGroupIds
     */
    setSmartTransferTicketUserGroups(userGroupIds) {
        return this.apiClient.issuePostRequest(`/v1/smart-transfers/settings/user-groups`, { userGroupIds });
    }
    /**
     * Get Smart Transfers user group ids. User group ids are used for Smart Transfer notifications
     */
    getSmartTransferTicketUserGroups() {
        return this.apiClient.issueGetRequest(`/v1/smart-transfers/settings/user-groups`);
    }
    /**
     * Delete Smart Transfers ticket term
     * @param ticketId
     * @param termId
     */
    deleteSmartTransferTicketTerms(ticketId, termId) {
        return this.apiClient.issueDeleteRequest(`/v1/smart-transfers/${ticketId}/terms/${termId}`);
    }
    /**
     * Get active policy (TAP) [BETA]
     */
    getActivePolicy() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tap/active_policy`);
        });
    }
    /**
     * Get draft policy (TAP) [BETA]
     */
    getDraft() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issueGetRequest(`/v1/tap/draft`);
        });
    }
    /**
     * Update draft policy (TAP) [BETA]
     * @param rules
     */
    updateDraft(rules) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePutRequest(`/v1/tap/draft`, { rules });
        });
    }
    /**
     * Publish draft policy (TAP) [BETA]
     * @param draftId
     */
    publishDraft(draftId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tap/draft`, { draftId });
        });
    }
    /**
     * Publish rules (TAP) [BETA]
     * @param rules
     */
    publishPolicyRules(rules) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiClient.issuePostRequest(`/v1/tap/publish`, { rules });
        });
    }
    getCommaSeparatedList(items) {
        return items ? items.join(",") : undefined;
    }
    /**
     * Get list of jobs for current tenant
     * @param fromTime beggining of time range in Unix Epoch
     * @param toTime ending of time range in Unix Epoch
     */
    getJobsForTenant(fromTime, toTime) {
        return this.apiClient.issueGetRequest(`/v1/batch/jobs?fromTime=${fromTime}&toTime=${toTime}`);
    }
    /**
     * Get job info by job ID
     * @param jobId
     */
    getJobById(jobId) {
        return this.apiClient.issueGetRequest(`/v1/batch/${jobId}`);
    }
    /**
     * Get tasks belonging to given job
     * @param jobId
     */
    getTasksByJobId(jobId) {
        return this.apiClient.issueGetRequest(`/v1/batch/${jobId}/tasks`);
    }
    /**
     * Cancel a job by ID
     * @param jobId
     */
    cancelJob(jobId) {
        return this.apiClient.issuePostRequest(`/v1/batch/${jobId}/cancel`, {});
    }
    /**
     * Pause a job by ID
     * @param jobId
     */
    pauseJob(jobId) {
        return this.apiClient.issuePostRequest(`/v1/batch/${jobId}/pause`, {});
    }
    /**
     * Continue a job by ID
     * @param jobId
     */
    continueJob(jobId) {
        return this.apiClient.issuePostRequest(`/v1/batch/${jobId}/continue`, {});
    }
    /**
     * Create multiple vault accounts in one bulk operation
     * @param count number of vault accounts
     * @param assetId optional asset id to create in each new account
     * @param requestOptions
     */
    createVaultAccountsBulk(count, assetId, requestOptions) {
        const body = {
            count,
            assetId
        };
        return this.apiClient.issuePostRequest(`/v1/vault/accounts/bulk`, body, requestOptions);
    }
    /**
     * Creates a new asset within a list of existing vault accounts
     * @param assetId The asset to add
     * @param vaultAccountIdFrom The first of the account ID range
     * @param vaultAccountIdTo The last of the account ID range
     * @param requestOptions
     */
    createVaultAssetsBulk(assetId, vaultAccountIdFrom, vaultAccountIdTo, requestOptions) {
        const body = {
            assetId, vaultAccountIdFrom, vaultAccountIdTo
        };
        return this.apiClient.issuePostRequest(`/v1/vault/assets/bulk`, body, requestOptions);
    }
    /**
     * Rescan transactions base on assetId and txHash
     * @param rescanTxs An array of RescanTx
     */
    rescanTransactionsBeta(rescanTxs) {
        return this.apiClient.issuePostRequest(`/v1/transactions/rescan`, rescanTxs);
    }
}
exports.FireblocksSDK = FireblocksSDK;
//# sourceMappingURL=fireblocks-sdk.js.map